{"meta":{"title":"Naraku的博客","subtitle":"","description":"WebCoder","author":"Ji Yin Liu","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"数据存储空间：堆空间和栈空间","date":"2020-04-24T02:16:12.000Z","path":"2020/04/24/browserWork3/","text":"","raw":"---\ntitle: 数据存储空间：堆空间和栈空间\ndate: 2020-04-24 10:16:12\ntags:\n---\n","content":"","slug":"browserWork3","updated":"2020-04-24T03:00:10.430Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/04/24/browserWork3/","excerpt":"","categories":[],"tags":[]},{"title":"运行时环境","date":"2020-04-24T02:16:06.000Z","path":"2020/04/24/browserWork2/","text":"","raw":"---\ntitle: 运行时环境\ndate: 2020-04-24 10:16:06\ntags:\n---\n","content":"","slug":"browserWork2","updated":"2020-04-24T02:32:09.572Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/04/24/browserWork2/","excerpt":"","categories":[],"tags":[]},{"title":"BrowserWork_render","date":"2020-04-23T02:16:29.000Z","path":"2020/04/23/BrowserWork-render/","text":"渲染流程默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。 浏览器进程发出资源请求，等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。渲染进程便开始页面解析和子资源加载了 构建 DOM 树样式计算（Recalculate Style） 1.CSS 文本转换为浏览器可以理解的结构——styleSheets。 2. 转换样式表中的属性值，使其标准化 3. 计算出 DOM 树中每个节点的具体样式 布局阶段1. 创建布局树 2. 布局计算分层 页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。 图层绘制渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，栅格化（raster）操作分块、光栅化 有的图层可以很大，通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。合成线程会将图层划分为图块（tile）然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。 通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。 合成和显示一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。 浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。 到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。 渲染流程总结一个完整的渲染流程大致可总结为如下： 渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。创建布局树，并计算元素的布局信息。对布局树进行分层，并生成分层树。为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。合成线程发送绘制图块命令DrawQuad给浏览器进程。浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。 更新了元素的几何属性（重排） 通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。重排需要更新完整的渲染流水线，所以开销也是最大的。 更新元素的绘制属性（重绘） 果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。 直接合成阶段我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。","raw":"---\ntitle: BrowserWork_render\ndate: 2020-04-23 10:16:29\ntags:\n---\n\n# 渲染流程 \n\n#### 默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。\n\n\nChrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。\n\n\n浏览器进程发出资源请求，等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。\n浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。渲染进程便开始页面解析和子资源加载了\n\n\n\n## 构建 DOM 树\n## 样式计算（Recalculate Style）\n   1.CSS 文本转换为浏览器可以理解的结构——styleSheets。\n   2. 转换样式表中的属性值，使其标准化\n   3. 计算出 DOM 树中每个节点的具体样式\n## 布局阶段\n    1. 创建布局树\n    2. 布局计算\n## 分层\n  页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。\n\n\n\n## 图层绘制\n    \n    渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，\n\n\n## 栅格化（raster）操作\n  ### 分块、光栅化\n   有的图层可以很大，通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。合成线程会将图层划分为图块（tile）然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。\n\n   通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。\n## 合成和显示\n\n\n一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。\n\n浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。\n\n到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。\n\n\n\n\n\n\n## 渲染流程总结\n\n一个完整的渲染流程大致可总结为如下：\n\n渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。\n渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。\n创建布局树，并计算元素的布局信息。\n对布局树进行分层，并生成分层树。\n为每个图层生成绘制列表，并将其提交到合成线程。\n合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。\n合成线程发送绘制图块命令DrawQuad给浏览器进程。\n浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。\n\n![渲染流水线](../Renderer/Renderer3.png)\n\n\n## 更新了元素的几何属性（重排）\n  通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。重排需要更新完整的渲染流水线，所以开销也是最大的。\n## 更新元素的绘制属性（重绘）\n   果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。\n\n## 直接合成阶段\n我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。","content":"<h1 id=\"渲染流程\"><a href=\"#渲染流程\" class=\"headerlink\" title=\"渲染流程\"></a>渲染流程</h1><h4 id=\"默认情况下，Chrome-会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。\"><a href=\"#默认情况下，Chrome-会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。\" class=\"headerlink\" title=\"默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。\"></a>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。</h4><p>Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。</p>\n<p>浏览器进程发出资源请求，等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。<br>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。渲染进程便开始页面解析和子资源加载了</p>\n<h2 id=\"构建-DOM-树\"><a href=\"#构建-DOM-树\" class=\"headerlink\" title=\"构建 DOM 树\"></a>构建 DOM 树</h2><h2 id=\"样式计算（Recalculate-Style）\"><a href=\"#样式计算（Recalculate-Style）\" class=\"headerlink\" title=\"样式计算（Recalculate Style）\"></a>样式计算（Recalculate Style）</h2><p>   1.CSS 文本转换为浏览器可以理解的结构——styleSheets。<br>   2. 转换样式表中的属性值，使其标准化<br>   3. 计算出 DOM 树中每个节点的具体样式</p>\n<h2 id=\"布局阶段\"><a href=\"#布局阶段\" class=\"headerlink\" title=\"布局阶段\"></a>布局阶段</h2><pre><code>1. 创建布局树\n2. 布局计算</code></pre><h2 id=\"分层\"><a href=\"#分层\" class=\"headerlink\" title=\"分层\"></a>分层</h2><p>  页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。</p>\n<h2 id=\"图层绘制\"><a href=\"#图层绘制\" class=\"headerlink\" title=\"图层绘制\"></a>图层绘制</h2><pre><code>渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，</code></pre><h2 id=\"栅格化（raster）操作\"><a href=\"#栅格化（raster）操作\" class=\"headerlink\" title=\"栅格化（raster）操作\"></a>栅格化（raster）操作</h2><h3 id=\"分块、光栅化\"><a href=\"#分块、光栅化\" class=\"headerlink\" title=\"分块、光栅化\"></a>分块、光栅化</h3><p>   有的图层可以很大，通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。合成线程会将图层划分为图块（tile）然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。</p>\n<p>   通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p>\n<h2 id=\"合成和显示\"><a href=\"#合成和显示\" class=\"headerlink\" title=\"合成和显示\"></a>合成和显示</h2><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>\n<p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>\n<p>到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。</p>\n<h2 id=\"渲染流程总结\"><a href=\"#渲染流程总结\" class=\"headerlink\" title=\"渲染流程总结\"></a>渲染流程总结</h2><p>一个完整的渲染流程大致可总结为如下：</p>\n<p>渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。<br>渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。<br>创建布局树，并计算元素的布局信息。<br>对布局树进行分层，并生成分层树。<br>为每个图层生成绘制列表，并将其提交到合成线程。<br>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。<br>合成线程发送绘制图块命令DrawQuad给浏览器进程。<br>浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</p>\n<p><img src=\"/2020/04/23/BrowserWork-render/Renderer/Renderer3.png\" alt=\"渲染流水线\"></p>\n<h2 id=\"更新了元素的几何属性（重排）\"><a href=\"#更新了元素的几何属性（重排）\" class=\"headerlink\" title=\"更新了元素的几何属性（重排）\"></a>更新了元素的几何属性（重排）</h2><p>  通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。重排需要更新完整的渲染流水线，所以开销也是最大的。</p>\n<h2 id=\"更新元素的绘制属性（重绘）\"><a href=\"#更新元素的绘制属性（重绘）\" class=\"headerlink\" title=\"更新元素的绘制属性（重绘）\"></a>更新元素的绘制属性（重绘）</h2><p>   果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</p>\n<h2 id=\"直接合成阶段\"><a href=\"#直接合成阶段\" class=\"headerlink\" title=\"直接合成阶段\"></a>直接合成阶段</h2><p>我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。</p>\n","slug":"BrowserWork-render","updated":"2020-04-24T04:33:38.300Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/04/23/BrowserWork-render/","excerpt":"","categories":[],"tags":[]},{"title":"事件循环系统","date":"2020-04-23T02:16:19.000Z","path":"2020/04/23/browserWork5/","text":"","raw":"---\ntitle: 事件循环系统\ndate: 2020-04-23 10:16:19\ntags:\n---\n","content":"","slug":"browserWork5","updated":"2020-04-24T03:00:42.088Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/04/23/browserWork5/","excerpt":"","categories":[],"tags":[]},{"title":"全局执行上下文和全局作用域","date":"2020-04-23T02:16:16.000Z","path":"2020/04/23/browserWork4/","text":"","raw":"---\ntitle: 全局执行上下文和全局作用域\ndate: 2020-04-23 10:16:16\ntags:\n---\n","content":"","slug":"browserWork4","updated":"2020-04-24T03:00:43.380Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/04/23/browserWork4/","excerpt":"","categories":[],"tags":[]},{"title":"BrowserWork","date":"2020-04-23T02:16:05.000Z","path":"2020/04/23/BrowserWork/","text":"Chrome架构 sequential process一个进程就是一个程序的运行实例， 在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。","raw":"---\ntitle: BrowserWork\ndate: 2020-04-23 10:16:05\ntags:\n---\n\nChrome架构\n\n\n![早期 Chrome 进程架构图](../BrowserWork/chrome2.png)\n![最新的 Chrome 进程架构图](../BrowserWork/chrome.png)\n\n![Chrome面向服务的架构进程模型图](../BrowserWork/chrome1.png)\n\n## sequential  process\n一个[进程](https://baike.baidu.com/item/进程)就是一个程序的运行实例， 在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。\n\n## 浏览器进程。\n主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。\n\n## 渲染进程。\n核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。\n\n## GPU 进程。\n其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。\n\n## 网络进程。\n主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。\n\n## 插件进程。\n主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。\n\n\n\n![Chrome进程管理](../BrowserWork/browser.png)","content":"<p>Chrome架构</p>\n<p><img src=\"/2020/04/23/BrowserWork/BrowserWork/chrome2.png\" alt=\"早期 Chrome 进程架构图\"><br><img src=\"/2020/04/23/BrowserWork/BrowserWork/chrome.png\" alt=\"最新的 Chrome 进程架构图\"></p>\n<p><img src=\"/2020/04/23/BrowserWork/BrowserWork/chrome1.png\" alt=\"Chrome面向服务的架构进程模型图\"></p>\n<h2 id=\"sequential-process\"><a href=\"#sequential-process\" class=\"headerlink\" title=\"sequential  process\"></a>sequential  process</h2><p>一个<a href=\"https://baike.baidu.com/item/进程\" target=\"_blank\" rel=\"noopener\">进程</a>就是一个程序的运行实例， 在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p>\n<h2 id=\"浏览器进程。\"><a href=\"#浏览器进程。\" class=\"headerlink\" title=\"浏览器进程。\"></a>浏览器进程。</h2><p>主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p>\n<h2 id=\"渲染进程。\"><a href=\"#渲染进程。\" class=\"headerlink\" title=\"渲染进程。\"></a>渲染进程。</h2><p>核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p>\n<h2 id=\"GPU-进程。\"><a href=\"#GPU-进程。\" class=\"headerlink\" title=\"GPU 进程。\"></a>GPU 进程。</h2><p>其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>\n<h2 id=\"网络进程。\"><a href=\"#网络进程。\" class=\"headerlink\" title=\"网络进程。\"></a>网络进程。</h2><p>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</p>\n<h2 id=\"插件进程。\"><a href=\"#插件进程。\" class=\"headerlink\" title=\"插件进程。\"></a>插件进程。</h2><p>主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p>\n<p><img src=\"/2020/04/23/BrowserWork/BrowserWork/browser.png\" alt=\"Chrome进程管理\"></p>\n","slug":"BrowserWork","updated":"2020-04-24T02:09:17.423Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/04/23/BrowserWork/","excerpt":"","categories":[],"tags":[]},{"title":"Template_Engine","date":"2020-04-23T02:00:33.000Z","path":"2020/04/23/Template-Engine/","text":"服务端模版引擎ExpressJSNunjucksVelocityEnjoyJspfreemarkervelocitythymeleafEnjoy 客户端模版引擎BaiduTemplateEJSMustacheHandlebarsNunjucksUnderscorePugMarkoJadeJsRenderSquirrellyjQuery TemplatingECTTemplate7Art-template 模版加载框架SeaJS","raw":"---\ntitle: Template_Engine\ndate: 2020-04-23 10:00:33\ntags:\n---\n\n##  服务端模版引擎\nExpressJS\nNunjucks\nVelocity \nEnjoy\nJsp\nfreemarker\nvelocity\nthymeleaf \nEnjoy\n##  客户端模版引擎\nBaiduTemplate   \nEJS   \nMustache  \nHandlebars  \nNunjucks \nUnderscore \nPug\nMarko\nJade \nJsRender\nSquirrelly\njQuery Templating\nECT\nTemplate7\nArt-template\n##  模版加载框架\nSeaJS\n\n\n\n","content":"<h2 id=\"服务端模版引擎\"><a href=\"#服务端模版引擎\" class=\"headerlink\" title=\"服务端模版引擎\"></a>服务端模版引擎</h2><p>ExpressJS<br>Nunjucks<br>Velocity<br>Enjoy<br>Jsp<br>freemarker<br>velocity<br>thymeleaf<br>Enjoy</p>\n<h2 id=\"客户端模版引擎\"><a href=\"#客户端模版引擎\" class=\"headerlink\" title=\"客户端模版引擎\"></a>客户端模版引擎</h2><p>BaiduTemplate<br>EJS<br>Mustache<br>Handlebars<br>Nunjucks<br>Underscore<br>Pug<br>Marko<br>Jade<br>JsRender<br>Squirrelly<br>jQuery Templating<br>ECT<br>Template7<br>Art-template</p>\n<h2 id=\"模版加载框架\"><a href=\"#模版加载框架\" class=\"headerlink\" title=\"模版加载框架\"></a>模版加载框架</h2><p>SeaJS</p>\n","slug":"Template-Engine","updated":"2020-04-23T05:48:18.798Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/04/23/Template-Engine/","excerpt":"","categories":[],"tags":[]},{"title":"Node_Frameworks","date":"2020-04-23T01:59:40.000Z","path":"2020/04/23/Node-Frameworks/","text":"Express.js如果您搜索Node.js Web框架，您肯定会经常看到Express.js。Express.js是***Node.js框架之一，并非没有理由 - 许多开发人员喜欢它来创建一个有效的平台来构建健壮的应用程序和API。它是众所周知的MEAN堆栈（MongoDB，Express，Angular和Node.js）的四个组件之一，它是一个经常用于构建Web应用程序的工具集。Express.js是Node.js的Web框架之一，拥有一套出色的文档，并享有很好的社区支持。这意味着您可以轻松找到Express.js的可重用组件和库。此外，它不需要使用特定的开发实践或特定工具，因此JavaScript开发人员可以获得的自由。 Koa2Koa2是Koa框架的第二个版本。Koa是创建Express.js的同一团队的产品; 然而，它与Express.js有很大的不同，并没有那么受欢迎。它现在正处于大量开发的过程中，版本2是该框架的稳定版本。Koa2属于Node.js MVC框架系列，其中MVC代表模型 - 视图 - 控制器。MVC的三个组件是作为应用程序数据的模型，视图是通过app UI的数据表示，控制器在模型和视图之间传递请求和更新。国内有很多框架是基于Koa2开发的，比如阿里的Egg.js。ThinkJS等 Sails.jsSails.js是Node.js的另一个MVC框架，它也是由Express.js背后的团队创建的。框架默认支持Socket.io，这使其成为社交媒体应用，消息传递工具和协作软件解决方案的***选择之一。 NestJSNestJS是Node.js框架中的新手。它专注于服务器端脚本，旨在构建服务器端应用程序。NestJS与其他Node.js Web应用程序框架的不同之处在于它使用TypeScript，TypeScript是JavaScript的特殊超集作为其编程语言。如果您熟悉Angular，它也使用TypeScript，那么使用NestJS构建后端没有问题，因为组件和语法看起来非常熟悉。有开发服务器渲染的同学应该对这个很熟悉。 LoopBackLoopBack是Express.js团队的另一个创建，基于Express.js开发。Loopback是API框架，允许您构建适用于任何客户端的API，并且可以连接各种设备。 Meteor.js***的全栈框架之一，可以轻松，直接地创建实时应用程序。优点在于它在服务器端和客户端使用相同的API，从而提高了整体应用程序性能。 Derby.jsDerby.js属于MVC框架，可用于客户端和服务器端脚本开发。 Hapi.js与我们在这里提到的许多其他框架不同，Hapi.js与Express.js无关，因此可能被认为是其竞争对手之一。Hapi.js最初是为了支持大型分布式团队的工作而创建的，该框架被认为是由大型分布式团队构建的企业级应用程序的***选择。Hapi.js通过专注于插件来实现出色的协作可能性，这些插件允许在不影响应用程序其余部分的情况下处理单独的组件。该框架非常适合创建可重用的组件，以帮助企业缩短开发时间。Hapi.js框架被用于为沃尔玛 零售连锁店，雅虎 网络服务提供商构建网络应用程序和网站，以及英国政府，信不信由你。 Mean.ioMean.io是另一个全栈框架，从它的名字可以看出它使用的是哪个堆栈。它提供了开箱即用的开始应用程序开发所需的一切，因此使用Mean.io可以立即开始工作。由于它是一个完整的开发堆栈，因此无需选择单独的组件并进行实验。此外，此框架中使用的所有工具都可以立即配置为一起使用。 Total.js一个MVC服务器端框架，非常适合创建Web应用程序。它在与支持MongoDB，MySQL，PostgreSQL的各种数据库的兼容性方面非常灵活，并且适用于许多前端网络，例如Angular，React和Ember。Total.js非常适合以相对较低的维护成本创建响应式应用程序，并且可以依赖它来提供足够的可伸缩性和性能。","raw":"---\ntitle: Node_Frameworks\ndate: 2020-04-23 09:59:40\ntags:\n---\n\n## Express.js\n如果您搜索Node.js Web框架，您肯定会经常看到Express.js。Express.js是***Node.js框架之一，并非没有理由 - 许多开发人员喜欢它来创建一个有效的平台来构建健壮的应用程序和API。它是众所周知的MEAN堆栈（MongoDB，Express，Angular和Node.js）的四个组件之一，它是一个经常用于构建Web应用程序的工具集。\nExpress.js是Node.js的Web框架之一，拥有一套出色的文档，并享有很好的社区支持。这意味着您可以轻松找到Express.js的可重用组件和库。此外，它不需要使用特定的开发实践或特定工具，因此JavaScript开发人员可以获得的自由。\n\n\n## Koa2\nKoa2是Koa框架的第二个版本。Koa是创建Express.js的同一团队的产品; 然而，它与Express.js有很大的不同，并没有那么受欢迎。它现在正处于大量开发的过程中，版本2是该框架的稳定版本。\nKoa2属于Node.js MVC框架系列，其中MVC代表模型 - 视图 - 控制器。MVC的三个组件是作为应用程序数据的模型，视图是通过app UI的数据表示，控制器在模型和视图之间传递请求和更新。\n国内有很多框架是基于Koa2开发的，比如阿里的Egg.js。ThinkJS等\n\n\n## Sails.js \nSails.js是Node.js的另一个MVC框架，它也是由Express.js背后的团队创建的。框架默认支持Socket.io，这使其成为社交媒体应用，消息传递工具和协作软件解决方案的***选择之一。\n\n\n## NestJS\nNestJS是Node.js框架中的新手。它专注于服务器端脚本，旨在构建服务器端应用程序。NestJS与其他Node.js Web应用程序框架的不同之处在于它使用TypeScript，TypeScript是JavaScript的特殊超集作为其编程语言。如果您熟悉Angular，它也使用TypeScript，那么使用NestJS构建后端没有问题，因为组件和语法看起来非常熟悉。\n有开发服务器渲染的同学应该对这个很熟悉。\n\n\n## LoopBack\nLoopBack是Express.js团队的另一个创建，基于Express.js开发。Loopback是API框架，允许您构建适用于任何客户端的API，并且可以连接各种设备。\n\n\n## Meteor.js\n***的全栈框架之一，可以轻松，直接地创建实时应用程序。优点在于它在服务器端和客户端使用相同的API，从而提高了整体应用程序性能。\n\n## Derby.js\nDerby.js属于MVC框架，可用于客户端和服务器端脚本开发。\n\n## Hapi.js\n与我们在这里提到的许多其他框架不同，Hapi.js与Express.js无关，因此可能被认为是其竞争对手之一。Hapi.js最初是为了支持大型分布式团队的工作而创建的，该框架被认为是由大型分布式团队构建的企业级应用程序的***选择。\nHapi.js通过专注于插件来实现出色的协作可能性，这些插件允许在不影响应用程序其余部分的情况下处理单独的组件。该框架非常适合创建可重用的组件，以帮助企业缩短开发时间。\nHapi.js框架被用于为沃尔玛 零售连锁店，雅虎 网络服务提供商构建网络应用程序和网站，以及英国政府，信不信由你。\n\n## Mean.io\nMean.io是另一个全栈框架，从它的名字可以看出它使用的是哪个堆栈。它提供了开箱即用的开始应用程序开发所需的一切，因此使用Mean.io可以立即开始工作。由于它是一个完整的开发堆栈，因此无需选择单独的组件并进行实验。此外，此框架中使用的所有工具都可以立即配置为一起使用。\n\n## Total.js\n一个MVC服务器端框架，非常适合创建Web应用程序。它在与支持MongoDB，MySQL，PostgreSQL的各种数据库的兼容性方面非常灵活，并且适用于许多前端网络，例如Angular，React和Ember。\nTotal.js非常适合以相对较低的维护成本创建响应式应用程序，并且可以依赖它来提供足够的可伸缩性和性能。","content":"<h2 id=\"Express-js\"><a href=\"#Express-js\" class=\"headerlink\" title=\"Express.js\"></a>Express.js</h2><p>如果您搜索Node.js Web框架，您肯定会经常看到Express.js。Express.js是***Node.js框架之一，并非没有理由 - 许多开发人员喜欢它来创建一个有效的平台来构建健壮的应用程序和API。它是众所周知的MEAN堆栈（MongoDB，Express，Angular和Node.js）的四个组件之一，它是一个经常用于构建Web应用程序的工具集。<br>Express.js是Node.js的Web框架之一，拥有一套出色的文档，并享有很好的社区支持。这意味着您可以轻松找到Express.js的可重用组件和库。此外，它不需要使用特定的开发实践或特定工具，因此JavaScript开发人员可以获得的自由。</p>\n<h2 id=\"Koa2\"><a href=\"#Koa2\" class=\"headerlink\" title=\"Koa2\"></a>Koa2</h2><p>Koa2是Koa框架的第二个版本。Koa是创建Express.js的同一团队的产品; 然而，它与Express.js有很大的不同，并没有那么受欢迎。它现在正处于大量开发的过程中，版本2是该框架的稳定版本。<br>Koa2属于Node.js MVC框架系列，其中MVC代表模型 - 视图 - 控制器。MVC的三个组件是作为应用程序数据的模型，视图是通过app UI的数据表示，控制器在模型和视图之间传递请求和更新。<br>国内有很多框架是基于Koa2开发的，比如阿里的Egg.js。ThinkJS等</p>\n<h2 id=\"Sails-js\"><a href=\"#Sails-js\" class=\"headerlink\" title=\"Sails.js\"></a>Sails.js</h2><p>Sails.js是Node.js的另一个MVC框架，它也是由Express.js背后的团队创建的。框架默认支持Socket.io，这使其成为社交媒体应用，消息传递工具和协作软件解决方案的***选择之一。</p>\n<h2 id=\"NestJS\"><a href=\"#NestJS\" class=\"headerlink\" title=\"NestJS\"></a>NestJS</h2><p>NestJS是Node.js框架中的新手。它专注于服务器端脚本，旨在构建服务器端应用程序。NestJS与其他Node.js Web应用程序框架的不同之处在于它使用TypeScript，TypeScript是JavaScript的特殊超集作为其编程语言。如果您熟悉Angular，它也使用TypeScript，那么使用NestJS构建后端没有问题，因为组件和语法看起来非常熟悉。<br>有开发服务器渲染的同学应该对这个很熟悉。</p>\n<h2 id=\"LoopBack\"><a href=\"#LoopBack\" class=\"headerlink\" title=\"LoopBack\"></a>LoopBack</h2><p>LoopBack是Express.js团队的另一个创建，基于Express.js开发。Loopback是API框架，允许您构建适用于任何客户端的API，并且可以连接各种设备。</p>\n<h2 id=\"Meteor-js\"><a href=\"#Meteor-js\" class=\"headerlink\" title=\"Meteor.js\"></a>Meteor.js</h2><p>***的全栈框架之一，可以轻松，直接地创建实时应用程序。优点在于它在服务器端和客户端使用相同的API，从而提高了整体应用程序性能。</p>\n<h2 id=\"Derby-js\"><a href=\"#Derby-js\" class=\"headerlink\" title=\"Derby.js\"></a>Derby.js</h2><p>Derby.js属于MVC框架，可用于客户端和服务器端脚本开发。</p>\n<h2 id=\"Hapi-js\"><a href=\"#Hapi-js\" class=\"headerlink\" title=\"Hapi.js\"></a>Hapi.js</h2><p>与我们在这里提到的许多其他框架不同，Hapi.js与Express.js无关，因此可能被认为是其竞争对手之一。Hapi.js最初是为了支持大型分布式团队的工作而创建的，该框架被认为是由大型分布式团队构建的企业级应用程序的***选择。<br>Hapi.js通过专注于插件来实现出色的协作可能性，这些插件允许在不影响应用程序其余部分的情况下处理单独的组件。该框架非常适合创建可重用的组件，以帮助企业缩短开发时间。<br>Hapi.js框架被用于为沃尔玛 零售连锁店，雅虎 网络服务提供商构建网络应用程序和网站，以及英国政府，信不信由你。</p>\n<h2 id=\"Mean-io\"><a href=\"#Mean-io\" class=\"headerlink\" title=\"Mean.io\"></a>Mean.io</h2><p>Mean.io是另一个全栈框架，从它的名字可以看出它使用的是哪个堆栈。它提供了开箱即用的开始应用程序开发所需的一切，因此使用Mean.io可以立即开始工作。由于它是一个完整的开发堆栈，因此无需选择单独的组件并进行实验。此外，此框架中使用的所有工具都可以立即配置为一起使用。</p>\n<h2 id=\"Total-js\"><a href=\"#Total-js\" class=\"headerlink\" title=\"Total.js\"></a>Total.js</h2><p>一个MVC服务器端框架，非常适合创建Web应用程序。它在与支持MongoDB，MySQL，PostgreSQL的各种数据库的兼容性方面非常灵活，并且适用于许多前端网络，例如Angular，React和Ember。<br>Total.js非常适合以相对较低的维护成本创建响应式应用程序，并且可以依赖它来提供足够的可伸缩性和性能。</p>\n","slug":"Node-Frameworks","updated":"2020-04-23T02:41:30.087Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/04/23/Node-Frameworks/","excerpt":"","categories":[],"tags":[]},{"title":"parsing","date":"2020-04-19T11:25:25.000Z","path":"2020/04/19/parsing/","text":"JS变量声明是由在tokenizer和parser之间的preparser处理的V8","raw":"---\ntitle: parsing\ndate: 2020-04-19 19:25:25\ntags:\n---\n##   JS变量声明是由在tokenizer和parser之间的preparser处理的\n\n[V8](https://github.com/v8/v8/blob/4b9b23521e6fd42373ebbcb20ebe03bf445494f9/src/parsing/preparser.cc)\n","content":"<h2 id=\"JS变量声明是由在tokenizer和parser之间的preparser处理的\"><a href=\"#JS变量声明是由在tokenizer和parser之间的preparser处理的\" class=\"headerlink\" title=\"JS变量声明是由在tokenizer和parser之间的preparser处理的\"></a>JS变量声明是由在tokenizer和parser之间的preparser处理的</h2><p><a href=\"https://github.com/v8/v8/blob/4b9b23521e6fd42373ebbcb20ebe03bf445494f9/src/parsing/preparser.cc\" target=\"_blank\" rel=\"noopener\">V8</a></p>\n","slug":"parsing","updated":"2020-04-19T13:09:54.686Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/04/19/parsing/","excerpt":"","categories":[],"tags":[]},{"title":"Interview","date":"2020-04-15T06:53:35.000Z","path":"2020/04/15/Interview/","text":"数学01 请叙述如何求得平面上任一线直线 f (x) = a． x + b 与任一点 P ( x_p, y_p) 的垂直距离? 02 请叙述如何计算两矢量: vector A = (x_a, y_a) , vector B = ( x_b, y_b) 之间的夹角 θ? 03 请叙述如何判断一个点是否在一个凸多边形里面? JavaScript / jQuery04 下方图片为一段动态新增列表项目的 code，请问被动态新增出来的 .js-list-item 为什么不会触发 click event？要怎么样修改才能正常执行？ 05 请说明以下例子的 console.log 会印出什么？请说明为何同样是印 this.name 却有不同的输出结果？ 06 请描述你对 AJAX 的理解 12 07 请比较 CSS 动画与 JavaScript 动画之间的差异，并举出你选择使用 CSS 动画与 JS 动画的例子与原因。 08 请写出下方程式码的结果？ 09 请写出打印出来的结果? 研发相关10 当一个事件被频繁触发，例如滑鼠移动、scrollbar拉动等，造成画面的不顺畅，请问该如何做优化处理呢? 11 请设计一个函数，函数名称自订，输入任意两个在 x-y 平面的向量，会回传两矢量的和。 (请自行定义传入与回传的矢量物件形式) 123function () &#123; &#125; 12 请设计一个函数，函数名称自订，输入一个数字 n，会回传小于 n 的所有质数的阵列 123function () &#123; &#125; 13 在 JavaScript 中，有什么情况是 immutable，并说明应用? 14 Temporal Dead Zone(TDZ)，在什么情况下会发生? HTML15 请描述 inline element 与 block element ，以及两者之间的差异？ 123一般情况下，行内元素只能包含数据和其他行内元素。而块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。默认情况下，行内元素不会以新行开始，而块级元素会新起一行。 16 请描述你对 SEO 的理解？另外，在开发时有什么需要注意的？ CSS17 排列出它们在套用 style 时的优先顺序(权重) 18 你曾用过哪些方法来最佳化你的 CSS 与提高效能？ 19 你曾用过哪些方法来解决跨浏览器相容性的问题？又曾用过什么工具来辅助测试？","raw":"---\ntitle: Interview\ndate: 2020-04-15 14:53:35\ntags:\n---\n\n\n## 数学\n\n01 请叙述如何求得平面上任一线直线 f (x) = a． x + b 与任一点 P ( x_p, y_p) 的垂直距离?\n\n\n02 请叙述如何计算两矢量: vector A = (x_a, y_a) , vector B = ( x_b, y_b) 之间的夹角 θ?\n\n03 请叙述如何判断一个点是否在一个凸多边形里面?\n\n\n## JavaScript / jQuery\n\n04 下方图片为一段动态新增列表项目的 code，请问被动态新增出来的 .js-list-item 为什么不会触发 click event？要怎么样修改才能正常执行？\n![](../Interview/Interview1.png)\n\n\n05 请说明以下例子的 console.log 会印出什么？请说明为何同样是印 this.name 却有不同的输出结果？\n![](../Interview/Interview2.jpg)\n\n\n06 请描述你对 AJAX 的理解\n``` HTML\n\n```\n\n\n07 请比较 CSS 动画与 JavaScript 动画之间的差异，并举出你选择使用 CSS 动画与 JS 动画的例子与原因。\n\n08 请写出下方程式码的结果？\n![](../Interview/Interview3.jpg)\n\n09 请写出打印出来的结果?\n![](../Interview/Interview4.jpg)\n\n## 研发相关\n\n10 当一个事件被频繁触发，例如滑鼠移动、scrollbar拉动等，造成画面的不顺畅，请问该如何做优化处理呢?\n\n11 请设计一个函数，函数名称自订，输入任意两个在 x-y 平面的向量，会回传两矢量的和。 (请自行定义传入与回传的矢量物件形式)\n\n``` JavaScript\n     function () {\n        \n     }\n\n```\n\n\n\n12 请设计一个函数，函数名称自订，输入一个数字 n，会回传小于 n 的所有质数的阵列\n``` JavaScript\n     function () {\n        \n     }\n\n```\n\n\n\n\n13 在 JavaScript 中，有什么情况是 immutable，并说明应用?\n\n\n\n\n14 Temporal Dead Zone(TDZ)，在什么情况下会发生?\n\n\n\n\n## HTML\n\n15 请描述 inline element 与 block element ，以及两者之间的差异？\n\n``` HTML\n    一般情况下，行内元素只能包含数据和其他行内元素。而块级元素可以包含行内元素和其他块级元素。\n    这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。\n    默认情况下，行内元素不会以新行开始，而块级元素会新起一行。\n```\n\n\n\n\n16 请描述你对 SEO 的理解？另外，在开发时有什么需要注意的？\n\n\n## CSS\n\n17 排列出它们在套用 style 时的优先顺序(权重)\n\n\n\n\n18 你曾用过哪些方法来最佳化你的 CSS 与提高效能？\n\n\n\n19 你曾用过哪些方法来解决跨浏览器相容性的问题？又曾用过什么工具来辅助测试？","content":"<h2 id=\"数学\"><a href=\"#数学\" class=\"headerlink\" title=\"数学\"></a>数学</h2><p>01 请叙述如何求得平面上任一线直线 f (x) = a． x + b 与任一点 P ( x_p, y_p) 的垂直距离?</p>\n<p>02 请叙述如何计算两矢量: vector A = (x_a, y_a) , vector B = ( x_b, y_b) 之间的夹角 θ?</p>\n<p>03 请叙述如何判断一个点是否在一个凸多边形里面?</p>\n<h2 id=\"JavaScript-jQuery\"><a href=\"#JavaScript-jQuery\" class=\"headerlink\" title=\"JavaScript / jQuery\"></a>JavaScript / jQuery</h2><p>04 下方图片为一段动态新增列表项目的 code，请问被动态新增出来的 .js-list-item 为什么不会触发 click event？要怎么样修改才能正常执行？<br><img src=\"/2020/04/15/Interview/Interview/Interview1.png\" alt></p>\n<p>05 请说明以下例子的 console.log 会印出什么？请说明为何同样是印 this.name 却有不同的输出结果？<br><img src=\"/2020/04/15/Interview/Interview/Interview2.jpg\" alt></p>\n<p>06 请描述你对 AJAX 的理解</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>07 请比较 CSS 动画与 JavaScript 动画之间的差异，并举出你选择使用 CSS 动画与 JS 动画的例子与原因。</p>\n<p>08 请写出下方程式码的结果？<br><img src=\"/2020/04/15/Interview/Interview/Interview3.jpg\" alt></p>\n<p>09 请写出打印出来的结果?<br><img src=\"/2020/04/15/Interview/Interview/Interview4.jpg\" alt></p>\n<h2 id=\"研发相关\"><a href=\"#研发相关\" class=\"headerlink\" title=\"研发相关\"></a>研发相关</h2><p>10 当一个事件被频繁触发，例如滑鼠移动、scrollbar拉动等，造成画面的不顺畅，请问该如何做优化处理呢?</p>\n<p>11 请设计一个函数，函数名称自订，输入任意两个在 x-y 平面的向量，会回传两矢量的和。 (请自行定义传入与回传的矢量物件形式)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>12 请设计一个函数，函数名称自订，输入一个数字 n，会回传小于 n 的所有质数的阵列</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>13 在 JavaScript 中，有什么情况是 immutable，并说明应用?</p>\n<p>14 Temporal Dead Zone(TDZ)，在什么情况下会发生?</p>\n<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><p>15 请描述 inline element 与 block element ，以及两者之间的差异？</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一般情况下，行内元素只能包含数据和其他行内元素。而块级元素可以包含行内元素和其他块级元素。</span><br><span class=\"line\">这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。</span><br><span class=\"line\">默认情况下，行内元素不会以新行开始，而块级元素会新起一行。</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>16 请描述你对 SEO 的理解？另外，在开发时有什么需要注意的？</p>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><p>17 排列出它们在套用 style 时的优先顺序(权重)</p>\n<p>18 你曾用过哪些方法来最佳化你的 CSS 与提高效能？</p>\n<p>19 你曾用过哪些方法来解决跨浏览器相容性的问题？又曾用过什么工具来辅助测试？</p>\n","slug":"Interview","updated":"2020-04-23T08:09:44.880Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/04/15/Interview/","excerpt":"","categories":[],"tags":[]},{"title":"loader","date":"2020-04-09T14:29:11.000Z","path":"2020/04/09/loader/","text":"","raw":"---\ntitle: loader\ndate: 2020-04-09 22:29:11\ntags:\n---\n","content":"","slug":"loader","updated":"2020-04-09T14:29:11.262Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/04/09/loader/","excerpt":"","categories":[],"tags":[]},{"title":"SAPI","date":"2020-03-26T14:05:59.000Z","path":"2020/03/26/SAPI/","text":"SAPI全称是Server Application Programming Interface,即服务器应用编程接口。","raw":"---\ntitle: SAPI\ndate: 2020-03-26 22:05:59\ntags:\n---\n\n\n\n\nSAPI全称是Server Application Programming Interface,即服务器应用编程接口。","content":"<p>SAPI全称是Server Application Programming Interface,即服务器应用编程接口。</p>\n","slug":"SAPI","updated":"2020-03-26T15:00:50.338Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/03/26/SAPI/","excerpt":"","categories":[],"tags":[]},{"title":"Rax","date":"2020-03-26T13:48:51.000Z","path":"2020/03/26/Rax/","text":"","raw":"---\ntitle: Rax\ndate: 2020-03-26 21:48:51\ntags:\n---\n","content":"","slug":"Rax","updated":"2020-03-26T13:48:51.833Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/03/26/Rax/","excerpt":"","categories":[],"tags":[]},{"title":"engineer","date":"2020-03-23T01:57:59.000Z","path":"2020/03/23/engineer/","text":"","raw":"---\nlayout: rendering\ntitle: engineer\ndate: 2020-03-23 09:57:59\ntags:\n---\n","content":"","slug":"engineer","updated":"2020-03-23T01:57:59.406Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/03/23/engineer/","excerpt":"","categories":[],"tags":[]},{"title":"Deno","date":"2020-03-13T07:56:23.000Z","path":"2020/03/13/Deno/","text":"","raw":"---\ntitle: Deno\ndate: 2020-03-13 15:56:23\ntags:\n---\n","content":"","slug":"Deno","updated":"2020-03-13T07:56:23.300Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/03/13/Deno/","excerpt":"","categories":[],"tags":[]},{"title":"firmware","date":"2020-03-04T02:02:13.000Z","path":"2020/03/04/firmware/","text":"","raw":"---\ntitle: firmware\ndate: 2020-03-04 10:02:13\ntags:\n---\n","content":"","slug":"firmware","updated":"2020-03-04T02:02:13.591Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/03/04/firmware/","excerpt":"","categories":[],"tags":[]},{"title":"Flutter","date":"2020-03-03T09:14:06.000Z","path":"2020/03/03/flutter/","text":"","raw":"---\ntitle: Flutter\ndate: 2020-03-03 17:14:06\ntags:\n---\n","content":"","slug":"flutter","updated":"2020-04-23T01:48:39.030Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/03/03/flutter/","excerpt":"","categories":[],"tags":[]},{"title":"UEFI","date":"2020-03-02T10:16:06.000Z","path":"2020/03/02/UEFI/","text":"","raw":"---\ntitle: UEFI\ndate: 2020-03-02 18:16:06\ntags:\n---\n","content":"","slug":"UEFI","updated":"2020-03-04T01:52:55.043Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/03/02/UEFI/","excerpt":"","categories":[],"tags":[]},{"title":"Code","date":"2020-03-01T05:15:34.000Z","path":"2020/03/01/code/","text":"1$ code . More info:","raw":"---\ntitle: Code\ndate: 2020-03-01 13:15:34\ntags:\n---\n\n``` bash\n$  code .\n```\n\nMore info: ","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  code .</span><br></pre></td></tr></table></figure>\n\n<p>More info: </p>\n","slug":"code","updated":"2020-04-24T02:04:45.170Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/03/01/code/","excerpt":"","categories":[],"tags":[]},{"title":"httpd","date":"2020-02-29T13:18:18.000Z","path":"2020/02/29/httpd/","text":"","raw":"---\ntitle: httpd\ndate: 2020-02-29 21:18:18\ntags:\n---\n","content":"","slug":"httpd","updated":"2020-02-29T13:18:18.224Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/02/29/httpd/","excerpt":"","categories":[],"tags":[]},{"title":"LAMP","date":"2020-02-19T14:39:46.000Z","path":"2020/02/19/LAMP/","text":"","raw":"---\ntitle: LAMP\ndate: 2020-02-19 22:39:46\ntags:\n---\n","content":"","slug":"LAMP","updated":"2020-02-19T14:39:46.796Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/02/19/LAMP/","excerpt":"","categories":[],"tags":[]},{"title":"CGI","date":"2020-02-18T11:40:27.000Z","path":"2020/02/18/CGI/","text":"","raw":"---\ntitle: CGI\ndate: 2020-02-18 19:40:27\ntags:\n---\n","content":"","slug":"CGI","updated":"2020-02-18T11:40:27.306Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/02/18/CGI/","excerpt":"","categories":[],"tags":[]},{"title":"dynein","date":"2020-02-17T10:30:59.000Z","path":"2020/02/17/dynein/","text":"","raw":"---\ntitle: dynein\ndate: 2020-02-17 18:30:59\ntags:\n---\n","content":"","slug":"dynein","updated":"2020-02-17T10:30:59.151Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/02/17/dynein/","excerpt":"","categories":[],"tags":[]},{"title":"Nginx","date":"2020-02-15T13:56:39.000Z","path":"2020/02/15/nginx/","text":"","raw":"---\ntitle: Nginx\ndate: 2020-02-15 21:56:39\ntags:\n---\n","content":"","slug":"nginx","updated":"2020-04-23T01:49:36.445Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/02/15/nginx/","excerpt":"","categories":[],"tags":[]},{"title":"Markdown 学习","date":"2020-02-13T01:37:59.000Z","path":"2020/02/13/markdown/","text":"用Markdown 编辑器写文章欢迎使用 Markdown 编辑器撰写技术文章，只专注于内容和技术，不再费心排版的问题。这是一份简要的 Markdown 引导指南，希望可以帮助您顺利的开始使用 Markdown 编辑器。 丰富的快捷键本 Markdown 编辑器支持丰富的格式快捷键，可以非常便捷、轻松的使用 Markdown 语言，形成优美的排版和内容格式。 支持的快捷键有： 加粗： Ctrl/Cmd + B 标题： Ctrl/Cmd + H 插入链接： Ctrl/Cmd + K 插入代码： Ctrl/Cmd + Shift + C 行内代码： Ctrl/Cmd + Shift + K 插入图片： Ctrl/Cmd + Shift + I 无序列表： Ctrl/Cmd + Shift + L 撤销： Ctrl/Cmd + Z 常用语法标题 语法格式：** ‘#’+’空格’+’文本’ ** ‘# 一级标题’ 列表 无序列表语法格式：** ‘-‘ + ‘空格’ ＋ ‘文本’ ** 文本一 文本二 文本三 有序列表语法格式：** ‘数字’ + ‘.’ + ‘空格’ + ‘文本’ ** 文本一 文本二 文本三 任务列表语法格式：** ‘-‘ + ‘空格’ + ‘[ ]’ + ‘文本’ ** 文本一 文本二 文本三 链接和图片在 Markdown 中插入链接不需要其他按钮，你只需要使用［显示文本］(链接地址)这样的格式语法即可。例如：稀土插入图片的语法与插入链接的语法很像，只是前面多了一个 !.语法如下：![图片的标注](图片链接地址) 引用 语法：** ‘&gt;’+’空格’+’文本’ ** 例如： Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 代码如下是代码段的语法： 1这是代码段 例如： 123456789def bubbleSort(alist): for passnum in range(len(alist)-1,0,-1): #print alist,passnum for i in range(passnum): if alist[i]&gt;alist[i+1]: temp = alist[i] alist[i] = alist[i+1] alist[i+1] = temp return alist 表格Markdown Extra 表格语法： 项目 价格 iPhone $560 iPad $780 iMac $1000 可以使用冒号来定义对齐方式： 项目 价格 数量 iPhone 6000 元 5 iPad 3800 元 12 iMac 10000 元 234 结语以上是最常见的 Markdown 的语法和格式，如果你还希望深入的学习 Markdown，可以参考这里Markdown语法，非常感谢使用** －Markdown 编辑器**,希望为您提供舒适的写作体验。 Markdown 标准语法官方文档Markdown 文档。 Latex 语法官方文档Latex 语法。 句法This link has no title attribute. learn markdownMore info: markdown","raw":"---\ntitle: Markdown 学习\ndate: 2020-02-13 09:37:59\ntags:\n---\n\n\n### 用Markdown 编辑器写文章\n\n欢迎使用 Markdown 编辑器撰写技术文章，只专注于内容和技术，不再费心排版的问题。这是一份简要的 Markdown 引导指南，希望可以帮助您顺利的开始使用 Markdown 编辑器。\n\n### 丰富的快捷键\n\n本 Markdown 编辑器支持丰富的格式快捷键，可以非常便捷、轻松的使用 Markdown 语言，形成优美的排版和内容格式。\n\n支持的快捷键有：\n\n* 加粗： `Ctrl/Cmd + B`\n* 标题： `Ctrl/Cmd + H`\n* 插入链接： `Ctrl/Cmd + K`\n* 插入代码： `Ctrl/Cmd + Shift + C`\n* 行内代码： `Ctrl/Cmd + Shift + K`\n* 插入图片： `Ctrl/Cmd + Shift + I`\n* 无序列表： `Ctrl/Cmd + Shift + L`\n* 撤销： `Ctrl/Cmd + Z`\n\n### 常用语法\n\n#### 标题\n\n> 语法格式：** '#'+'空格'+'文本' **\n\n'# 一级标题'\n\n\n#### 列表\n\n> 无序列表语法格式：** '-' + '空格' ＋ '文本' **\n\n- 文本一\n- 文本二\n- 文本三\n\n> 有序列表语法格式：** '数字' + '.' + '空格' + '文本' **\n\n1. 文本一\n2. 文本二\n3. 文本三\n\n> 任务列表语法格式：** '-' + '空格' + '[ ]' + '文本' **\n\n- [x] 文本一\n- [ ] 文本二\n- [ ] 文本三\n\n#### 链接和图片\n\n在 Markdown 中插入链接不需要其他按钮，你只需要使用`［显示文本］(链接地址)`这样的格式语法即可。例如：\n[稀土](https://gold.xitu.io)\n插入图片的语法与插入链接的语法很像，只是前面多了一个 `!`.语法如下：\n`![图片的标注](图片链接地址)`\n\n#### 引用\n\n> 语法：** '>'+'空格'+'文本' **\n\n\n例如：\n\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。\n\n#### 代码\n\n如下是代码段的语法：\n\n<pre>\n```编程语言\n 这是代码段\n```\n</pre>\n\n例如：\n\n``` python\ndef bubbleSort(alist):\n for passnum in range(len(alist)-1,0,-1):\n #print alist,passnum\n for i in range(passnum):\n if alist[i]>alist[i+1]:\n temp = alist[i]\n alist[i] = alist[i+1]\n alist[i+1] = temp\n return alist\n```\n\n#### 表格\n\n**Markdown　Extra**　表格语法：\n\n项目 | 价格\n-------- | ---\niPhone | $560\niPad | $780\niMac | $1000\n\n可以使用冒号来定义对齐方式：\n\n| 项目 | 价格 | 数量 |\n| :-------- | --------:| :--: |\n| iPhone | 6000 元 | 5 |\n| iPad | 3800 元 | 12 |\n| iMac | 10000 元 | 234 |\n\n\n#### 结语\n\n以上是最常见的 Markdown 的语法和格式，如果你还希望深入的学习 Markdown，可以参考这里[Markdown语法](https://www.appinn.com/markdown/)，非常感谢使用** －Markdown 编辑器**,希望为您提供舒适的写作体验。\n\n## Markdown 标准语法\n官方文档[Markdown 文档](https://www.markdownguide.org/basic-syntax/)。\n \n## Latex 语法\n官方文档[Latex 语法](http://web.ift.uib.no/Teori/KURS/WRK/TeX/symALL.html)。\n\n\n\n\n\n\n## 句法\n[This link](https://aoorjgcs.github.io/) has no title attribute.\n\n\n\n### learn markdown\n\nMore info: [markdown](https://daringfireball.net/projects/markdown/)\n","content":"<h3 id=\"用Markdown-编辑器写文章\"><a href=\"#用Markdown-编辑器写文章\" class=\"headerlink\" title=\"用Markdown 编辑器写文章\"></a>用Markdown 编辑器写文章</h3><p>欢迎使用 Markdown 编辑器撰写技术文章，只专注于内容和技术，不再费心排版的问题。这是一份简要的 Markdown 引导指南，希望可以帮助您顺利的开始使用 Markdown 编辑器。</p>\n<h3 id=\"丰富的快捷键\"><a href=\"#丰富的快捷键\" class=\"headerlink\" title=\"丰富的快捷键\"></a>丰富的快捷键</h3><p>本 Markdown 编辑器支持丰富的格式快捷键，可以非常便捷、轻松的使用 Markdown 语言，形成优美的排版和内容格式。</p>\n<p>支持的快捷键有：</p>\n<ul>\n<li>加粗： <code>Ctrl/Cmd + B</code></li>\n<li>标题： <code>Ctrl/Cmd + H</code></li>\n<li>插入链接： <code>Ctrl/Cmd + K</code></li>\n<li>插入代码： <code>Ctrl/Cmd + Shift + C</code></li>\n<li>行内代码： <code>Ctrl/Cmd + Shift + K</code></li>\n<li>插入图片： <code>Ctrl/Cmd + Shift + I</code></li>\n<li>无序列表： <code>Ctrl/Cmd + Shift + L</code></li>\n<li>撤销： <code>Ctrl/Cmd + Z</code></li>\n</ul>\n<h3 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h3><h4 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h4><blockquote>\n<p>语法格式：** ‘#’+’空格’+’文本’ **</p>\n</blockquote>\n<p>‘# 一级标题’</p>\n<h4 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h4><blockquote>\n<p>无序列表语法格式：** ‘-‘ + ‘空格’ ＋ ‘文本’ **</p>\n</blockquote>\n<ul>\n<li>文本一</li>\n<li>文本二</li>\n<li>文本三</li>\n</ul>\n<blockquote>\n<p>有序列表语法格式：** ‘数字’ + ‘.’ + ‘空格’ + ‘文本’ **</p>\n</blockquote>\n<ol>\n<li>文本一</li>\n<li>文本二</li>\n<li>文本三</li>\n</ol>\n<blockquote>\n<p>任务列表语法格式：** ‘-‘ + ‘空格’ + ‘[ ]’ + ‘文本’ **</p>\n</blockquote>\n<ul>\n<li><input checked disabled type=\"checkbox\"> 文本一</li>\n<li><input disabled type=\"checkbox\"> 文本二</li>\n<li><input disabled type=\"checkbox\"> 文本三</li>\n</ul>\n<h4 id=\"链接和图片\"><a href=\"#链接和图片\" class=\"headerlink\" title=\"链接和图片\"></a>链接和图片</h4><p>在 Markdown 中插入链接不需要其他按钮，你只需要使用<code>［显示文本］(链接地址)</code>这样的格式语法即可。例如：<br><a href=\"https://gold.xitu.io\" target=\"_blank\" rel=\"noopener\">稀土</a><br>插入图片的语法与插入链接的语法很像，只是前面多了一个 <code>!</code>.语法如下：<br><code>![图片的标注](图片链接地址)</code></p>\n<h4 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h4><blockquote>\n<p>语法：** ‘&gt;’+’空格’+’文本’ **</p>\n</blockquote>\n<p>例如：</p>\n<blockquote>\n<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。</p>\n</blockquote>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>如下是代码段的语法：</p>\n<pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是代码段</span><br></pre></td></tr></table></figure>\n</pre>\n\n<p>例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(alist)</span>:</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> passnum <span class=\"keyword\">in</span> range(len(alist)<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>):</span><br><span class=\"line\"> <span class=\"comment\">#print alist,passnum</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(passnum):</span><br><span class=\"line\"> <span class=\"keyword\">if</span> alist[i]&gt;alist[i+<span class=\"number\">1</span>]:</span><br><span class=\"line\"> temp = alist[i]</span><br><span class=\"line\"> alist[i] = alist[i+<span class=\"number\">1</span>]</span><br><span class=\"line\"> alist[i+<span class=\"number\">1</span>] = temp</span><br><span class=\"line\"> <span class=\"keyword\">return</span> alist</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h4><p><strong>Markdown　Extra</strong>　表格语法：</p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>价格</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>iPhone</td>\n<td>$560</td>\n</tr>\n<tr>\n<td>iPad</td>\n<td>$780</td>\n</tr>\n<tr>\n<td>iMac</td>\n<td>$1000</td>\n</tr>\n</tbody></table>\n<p>可以使用冒号来定义对齐方式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">项目</th>\n<th align=\"right\">价格</th>\n<th align=\"center\">数量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">iPhone</td>\n<td align=\"right\">6000 元</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td align=\"left\">iPad</td>\n<td align=\"right\">3800 元</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td align=\"left\">iMac</td>\n<td align=\"right\">10000 元</td>\n<td align=\"center\">234</td>\n</tr>\n</tbody></table>\n<h4 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h4><p>以上是最常见的 Markdown 的语法和格式，如果你还希望深入的学习 Markdown，可以参考这里<a href=\"https://www.appinn.com/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown语法</a>，非常感谢使用** －Markdown 编辑器**,希望为您提供舒适的写作体验。</p>\n<h2 id=\"Markdown-标准语法\"><a href=\"#Markdown-标准语法\" class=\"headerlink\" title=\"Markdown 标准语法\"></a>Markdown 标准语法</h2><p>官方文档<a href=\"https://www.markdownguide.org/basic-syntax/\" target=\"_blank\" rel=\"noopener\">Markdown 文档</a>。</p>\n<h2 id=\"Latex-语法\"><a href=\"#Latex-语法\" class=\"headerlink\" title=\"Latex 语法\"></a>Latex 语法</h2><p>官方文档<a href=\"http://web.ift.uib.no/Teori/KURS/WRK/TeX/symALL.html\" target=\"_blank\" rel=\"noopener\">Latex 语法</a>。</p>\n<h2 id=\"句法\"><a href=\"#句法\" class=\"headerlink\" title=\"句法\"></a>句法</h2><p><a href=\"https://aoorjgcs.github.io/\" target=\"_blank\" rel=\"noopener\">This link</a> has no title attribute.</p>\n<h3 id=\"learn-markdown\"><a href=\"#learn-markdown\" class=\"headerlink\" title=\"learn markdown\"></a>learn markdown</h3><p>More info: <a href=\"https://daringfireball.net/projects/markdown/\" target=\"_blank\" rel=\"noopener\">markdown</a></p>\n","slug":"markdown","updated":"2020-04-23T01:50:28.348Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/02/13/markdown/","excerpt":"","categories":[],"tags":[]},{"title":"blog","date":"2020-02-10T12:41:08.000Z","path":"2020/02/10/blog/","text":"","raw":"---\ntitle: blog\ndate: 2020-02-10 20:41:08\ntags:\n---","content":"","slug":"blog","updated":"2020-03-04T12:41:43.061Z","comments":true,"link":"","permalink":"http://yoursite.com/2020/02/10/blog/","excerpt":"","categories":[],"tags":[]}]}